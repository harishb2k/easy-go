package emissary

import (
	"fmt"
	"github.com/harishb2k/easy-go/basic"
	. "github.com/harishb2k/easy-go/test_http"
	"github.com/jarcoal/httpmock"
	"github.com/stretchr/testify/assert"
	"gopkg.in/yaml.v3"
	"io/ioutil"
	"testing"
)

type autoGenerated struct {
	UserID    int    `json:"userId"`
	ID        int    `json:"id"`
	Title     string `json:"title"`
	Completed bool   `json:"completed"`
}

type localConfig struct {
	EmissaryConfiguration Configuration `yaml:"emissaryConfiguration"`
}

var config = localConfig{}
var sampleJson = `{
                "userId": 1,  
                "id": 1,
                "title": "testme", 
                "completed": false
        }`

var commandContext CommandContext

func init() {
	data, err := ioutil.ReadFile("./testdata/app.yml")
	if err == nil {
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			panic(err)
		}
	}

	err = basic.ReadYaml("./testdata/app.yml", &config)
	if err != nil {
		fmt.Println("Failed to read config", err)

	}
	commandContext, _ = NewCommandContext(&config.EmissaryConfiguration, basic.NoOpLogger{})
}

func TestHttpCommand(t *testing.T) {
	httpmock.Activate()
	defer httpmock.DeactivateAndReset()

	res := autoGenerated{}
	SetupGetHttpResponse("http://jsonplaceholder.typicode.com:80/todos/1", sampleJson, &res)

	service := config.EmissaryConfiguration.ServiceList["serviceA"]
	api := config.EmissaryConfiguration.ServiceList["serviceA"].ApiList["update"]
	service.Name = "serviceA"
	api.Name = "update"

	// Command setup
	httpCommand := HttpCommand{
		Service: service,
		Api:     api,
	}
	httpCommand.Setup(basic.NoOpLogger{})

	request := CommandRequest{
		BodyFunc:   DefaultObjectToBodyFunc(&internalResult{Title: "Some Title"}),
		ResultFunc: DefaultJsonResultFunc(&internalResult{}),
	}

	result, _ := httpCommand.Execute(request)
	var r = result.(*internalResult)
	assert.Equal(t, 1, r.ID, "ID must be 2")
}

func TestHttpCommandTimeout(t *testing.T) {
	httpmock.Activate()
	defer httpmock.DeactivateAndReset()
	res := autoGenerated{}
	SetupGetHttpResponseDelay("http://jsonplaceholder.typicode.com:80/todos/1", sampleJson, &res, 1000)

	service := config.EmissaryConfiguration.ServiceList["serviceA"]
	api := config.EmissaryConfiguration.ServiceList["serviceA"].ApiList["update"]
	service.Name = "serviceA"
	api.Name = "update"
	api.RequestTimeout = 1

	// Command setup
	httpCommand := HystrixHttpCommand{
		HttpCommand: HttpCommand{
			Service: service,
			Api:     api,
		},
	}
	httpCommand.Setup(basic.NoOpLogger{})

	request := CommandRequest{
		BodyFunc:   DefaultObjectToBodyFunc(&internalResult{Title: "Some Title"}),
		ResultFunc: DefaultJsonResultFunc(&internalResult{}),
	}

	result, err := httpCommand.Execute(request)
	assert.Equal(t, result, nil, "result must be null")
	assert.EqualError(t, err, "hystrix: timeout", "we must get hystrix error")
}

func TestHttpCommandWithHelper(t *testing.T) {
	httpmock.Activate()
	defer httpmock.DeactivateAndReset()
	res := autoGenerated{}
	SetupGetHttpResponse("http://jsonplaceholder.typicode.com:80/todos/1", sampleJson, &res)

	result, _ := commandContext.Execute(
		"serviceA",
		"update",
		CommandRequest{
			BodyFunc:   DefaultObjectToBodyFunc(&internalResult{Title: "Some Title"}),
			ResultFunc: DefaultJsonResultFunc(&internalResult{}),
		},
	)
	var r = result.(*internalResult)
	assert.Equal(t, 1, r.ID, "ID must be 2")
}

func TestHttpCommandWithHelperPathParam(t *testing.T) {
	httpmock.Activate()
	defer httpmock.DeactivateAndReset()
	res := autoGenerated{}
	SetupGetHttpResponse("http://jsonplaceholder.typicode.com:80/todos/1", sampleJson, &res)

	result, _ := commandContext.Execute(
		"serviceB",
		"update",
		CommandRequest{
			PathParamFunc: DefaultPathParamFunc("id", 1),
			BodyFunc:      DefaultObjectToBodyFunc(&internalResult{Title: "Some Title"}),
			ResultFunc:    DefaultJsonResultFunc(&internalResult{}),
		},
	)
	var r = result.(*internalResult)
	assert.Equal(t, 1, r.ID, "ID must be 2")
}

type internalResult struct {
	UserID    int    `json:"userId"`
	ID        int    `json:"id"`
	Title     string `json:"title"`
	Completed bool   `json:"completed"`
}
